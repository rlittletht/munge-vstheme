<# 
.SYNOPSIS
  Restore CT_RAW colors in a Visual Studio .vstheme file using a change log.

.DESCRIPTION
  - Reads a CSV-like log file with lines "category,ui name,original color,new color"
    produced by the forward script.
  - Builds a reverse mapping from NewColor (#RRGGBB) -> OriginalColor (#RRGGBB).
  - Scans the .vstheme (as raw text) and replaces every CT_RAW Source="AARRGGBB" whose
    RGB matches a NewColor with the mapped OriginalColor, preserving the original alpha byte.

.PARAMETER InputFile
  Path to the source .vstheme XML file to process.

.PARAMETER LogFile
  Path to the log file generated by the forward script.

.PARAMETER OutputFile
  Path to write the restored .vstheme.

.EXAMPLE
  .\Restore-VsThemeColors.ps1 -InputFile .\MyTheme-Edited.vstheme -LogFile .\changes.log -OutputFile .\MyTheme-Restored.vstheme
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [string]$InputFile,

    [Parameter(Mandatory=$true)]
    [string]$LogFile,

    [Parameter(Mandatory=$true)]
    [string]$OutputFile
)

#region Utilities

function Ensure-ParentDirectory {
    param([string]$FilePath)
    if ([string]::IsNullOrWhiteSpace($FilePath)) { throw "Path cannot be empty." }
    $full = [System.IO.Path]::GetFullPath($FilePath)
    $parent = [System.IO.Path]::GetDirectoryName($full)
    if ($parent -and -not (Test-Path -LiteralPath $parent)) {
        New-Item -ItemType Directory -Path $parent -Force | Out-Null
    }
    $full
}

function Parse-HexRgb {
    param([string]$Rgb) # "#RRGGBB" or "RRGGBB"
    if ([string]::IsNullOrWhiteSpace($Rgb)) { throw "Empty RGB string." }
    if ($Rgb.StartsWith('#')) { $Rgb = $Rgb.Substring(1) }
    if ($Rgb -notmatch '^[0-9A-Fa-f]{6}$') {
        throw "Invalid RGB '$Rgb' (expected #RRGGBB or RRGGBB)."
    }
    # return lowercase "rrggbb"
    return $Rgb.ToLowerInvariant()
}

function Split-ArgbHex8 {
    param([string]$ArgbHex8) # "AARRGGBB"
    if ($ArgbHex8 -notmatch '^[0-9A-Fa-f]{8}$') {
        throw "Invalid ARGB '$ArgbHex8'. Expected 8 hex chars (AARRGGBB)."
    }
    $a = [Convert]::ToByte($ArgbHex8.Substring(0,2),16)
    $r = [Convert]::ToByte($ArgbHex8.Substring(2,2),16)
    $g = [Convert]::ToByte($ArgbHex8.Substring(4,2),16)
    $b = [Convert]::ToByte($ArgbHex8.Substring(6,2),16)
    [byte[]]@($a,$r,$g,$b)
}

function Join-ArgbHex8 {
    param([byte]$A,[byte]$R,[byte]$G,[byte]$B)
    ('{0:X2}{1:X2}{2:X2}{3:X2}' -f $A,$R,$G,$B)
}

# Regex for <Background>/<Foreground> start tag containing Type="CT_RAW" and Source="AARRGGBB"
# Captures: tag name and the 8-hex Source payload
$TagWithRawAndSourcePattern = '(?is)<(?<tag>Background|Foreground)\b(?=[^>]*\bType\s*=\s*["'']CT_RAW["''])(?=[^>]*\bSource\s*=\s*["''][0-9A-Fa-f]{8}["''])[^>]*?\bSource\s*=\s*(?<pre>["''])(?<hex>[0-9A-Fa-f]{8})(?<post>["''])'

#endregion

#region Log parsing -> reverse map (new -> original)

function Build-ReverseMapFromLog {
    param([string]$Path)

    if (-not (Test-Path -LiteralPath $Path)) {
        throw "Log file not found: $Path"
    }

    # Read log and parse as CSV with our own headers; supports quoted fields & commas in names
    $raw = Get-Content -LiteralPath $Path -Raw -ErrorAction Stop
    if ([string]::IsNullOrWhiteSpace($raw)) {
        throw "Log file '$Path' is empty."
    }

    $lines = $raw -split '(\r?\n)+'
    $csvText = ($lines | Where-Object { $_ -ne '' -and -not $_.Trim().StartsWith('#') }) -join [Environment]::NewLine
    if ([string]::IsNullOrWhiteSpace($csvText)) {
        throw "Log file '$Path' contains no data lines."
    }

    # ConvertFrom-Csv with explicit headers
    $records = $csvText | ConvertFrom-Csv -Delimiter ',' -Header @('Category','UiName','Original','New')

    # Build mapping: new (#rrggbb) -> original (#rrggbb)
    $map = @{}

    foreach ($rec in $records) {
        try {
            $newKey  = Parse-HexRgb $rec.New
            $origVal = Parse-HexRgb $rec.Original
        } catch {
            throw "Malformed log row: $($rec | ConvertTo-Json -Compress) - $($_.Exception.Message)"
        }

        if ($map.ContainsKey($newKey) -and $map[$newKey] -ne $origVal) {
            throw "Conflict in log file: new color '#$newKey' maps to both '#$($map[$newKey])' and '#$origVal'."
        }
        $map[$newKey] = $origVal
    }

    return $map
}

#endregion

#region Theme text replacement using reverse map

function Restore-ColorsInText {
    param(
        [string]$XmlText,
        [hashtable]$ReverseMap # key: new rrggbb (lower), value: original rrggbb (lower)
    )

    $re = [System.Text.RegularExpressions.Regex]::new($TagWithRawAndSourcePattern, 'IgnoreCase, Singleline')

    $evaluator = [System.Text.RegularExpressions.MatchEvaluator]{
        param([System.Text.RegularExpressions.Match]$m)

        $aarrggbb = $m.Groups['hex'].Value
        $argb = Split-ArgbHex8 $aarrggbb
        $a = $argb[0]; $r = $argb[1]; $g = $argb[2]; $b = $argb[3]

        $rgbKey = ('{0:X2}{1:X2}{2:X2}' -f $r,$g,$b).ToLowerInvariant()

        if (-not $ReverseMap.ContainsKey($rgbKey)) {
            # Not a color we need to reverse; return tag text unchanged
            return $m.Value
        }

        # Map back to original RGB, preserve alpha
        $origRgbLower = $ReverseMap[$rgbKey]
        $origR = [Convert]::ToByte($origRgbLower.Substring(0,2), 16)
        $origG = [Convert]::ToByte($origRgbLower.Substring(2,2), 16)
        $origB = [Convert]::ToByte($origRgbLower.Substring(4,2), 16)

        $newHex = Join-ArgbHex8 -A $a -R $origR -G $origG -B $origB

        # Replace only the 8 hex digits inside Source="AARRGGBB"
        return ($m.Value.Remove($m.Groups['hex'].Index - $m.Index, $m.Groups['hex'].Length).Insert($m.Groups['hex'].Index - $m.Index, $newHex))
    }

    return $re.Replace($XmlText, $evaluator)
}

#endregion

#region Main

try {
    if (-not (Test-Path -LiteralPath $InputFile)) { throw "Input file not found: $InputFile" }

    # Build reverse map from log
    $reverseMap = Build-ReverseMapFromLog -Path $LogFile
    if ($reverseMap.Count -eq 0) {
        Write-Warning "No mappings found in log; writing input unchanged."
    }

    # Read the theme as raw text to preserve entities and formatting
    $text = Get-Content -LiteralPath $InputFile -Raw -ErrorAction Stop

    # Apply replacements
    $updated = if ($reverseMap.Count -gt 0) { Restore-ColorsInText -XmlText $text -ReverseMap $reverseMap } else { $text }

    # Write output
    $outPath = Ensure-ParentDirectory -FilePath $OutputFile
    Set-Content -LiteralPath $outPath -Value $updated -Encoding UTF8

    Write-Host ("Done. Restored colors using {0} mapping(s). Output: {1}" -f $reverseMap.Count, $outPath)
}
catch {
    Write-Error $_.Exception.Message
    exit 1
}

#endregion
